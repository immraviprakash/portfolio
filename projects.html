<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" type="image/png" href="favicon.png">

<title>Projects</title>
<meta name="description" content="Projects — neon, holo shader, particles, glass cards. Matches Skills visuals." />
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  :root{
    --cyan:#00e6ff;
    --magenta:#b34bff;
    --accent:#88ffe6;
    --muted:#cbd6df;
    --bg-ui: rgba(2,4,7,0.52);
    --glass: rgba(255,255,255,0.02);
    --glass-border: rgba(255,255,255,0.04);
    --max-w:1200px;
    --card-radius:14px;
  }

  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family:"Orbitron","Share Tech Mono",monospace;
    color:#fff; background:#000; overflow:hidden;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* full-screen canvases */
  canvas#bg-shader, canvas#particles { position:fixed; inset:0; width:100%; height:100%; z-index:0; display:block; }
  .screen-overlay { position:fixed; inset:0; pointer-events:none; z-index:3; background: repeating-linear-gradient(to bottom, rgba(255,255,255,0.01) 0 1px, transparent 1px 4px); mix-blend-mode: overlay; opacity:0.22; }

  /* back button — bottom right, slightly larger than ghost */
  .back-btn {
    position: fixed;
    right: 20px;
    bottom: 20px;
    z-index: 50;
    display: inline-block;
  }
  .back-btn .btn {
    font-size: 15px;
    padding: 12px 18px;
    border-radius: 12px;
  }

  /* top controls */
  .top-controls { position:fixed; right:18px; top:18px; z-index:40; display:flex; gap:10px; align-items:center; padding:8px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); backdrop-filter: blur(6px); }
  .hud-btn { padding:8px 10px; border-radius:8px; background: transparent; color:var(--accent); font-weight:800; font-size:12px; border:1px solid rgba(255,255,255,0.04); cursor:pointer }
  .perf-indicator { font-size:12px; color:var(--muted) }

  /* page */
  .page { position:relative; z-index:6; max-width:var(--max-w); margin:34px auto; padding:28px 20px 80px; display:grid; gap:22px; }
  header{ display:flex; align-items:center; justify-content:center; position:relative; }
  .title {
    font-family:"Share Tech Mono"; font-size:clamp(18px,3.8vw,34px); color:var(--muted);
    border-right:2px solid var(--cyan); display:inline-block; white-space:nowrap; overflow:hidden;
    width:0; animation:typing 2.6s steps(20,end) forwards; text-shadow:0 0 8px rgba(0,230,255,0.04);
  }
  @keyframes typing { from{width:0} to{width:20ch} }

  .toolbar { display:flex; gap:12px; justify-content:center; align-items:center; margin-top:6px; }

  /* chips */
  .search-wrap { display:flex; gap:8px; align-items:center; }
  .chip { padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,0.04); background:linear-gradient(90deg, rgba(255,255,255,0.008), rgba(255,255,255,0.005)); color:var(--muted); cursor:pointer; font-weight:700; }
  .chip.active { color:var(--cyan); box-shadow: 0 6px 24px rgba(0,230,255,0.06) inset, 0 6px 30px rgba(0,230,255,0.04); transform:translateY(-2px); }

  /* Reused contact-like buttons */
  .btn { background:linear-gradient(90deg,var(--cyan),var(--magenta)); color:#001; padding:10px 14px; border-radius:10px; font-weight:800; border:none; cursor:pointer; box-shadow:0 12px 44px rgba(0,0,0,0.6); transition: transform .14s ease, filter .14s; }
  .btn.ghost { background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); box-shadow:none; text-decoration:none; display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; border-radius:10px; }

  /* grid */
  .grid { display:grid; gap:20px; grid-template-columns: repeat(auto-fit, minmax(320px,1fr)); margin-top:12px; }

  /* card */
  .card {
    position:relative; border-radius:var(--card-radius); overflow:visible; padding:18px; min-height:220px;
    background: linear-gradient(180deg, rgba(8,8,10,0.62), rgba(8,10,14,0.42));
    border:1px solid var(--glass-border); box-shadow: 0 14px 60px rgba(0,0,0,0.6);
    transform-style:preserve-3d; transition: transform .38s cubic-bezier(.18,.9,.24,1), box-shadow .38s, opacity .48s;
    text-decoration:none; color:inherit;
  }
  .card::before{ content:""; position:absolute; inset:0; border-radius:inherit; pointer-events:none; mix-blend-mode:screen; background: linear-gradient(90deg, rgba(255,255,255,0.00) 0%, rgba(255,255,255,0.03) 45%, rgba(255,255,255,0.00) 90%); transform: translateX(-110%); opacity:.6; transition:transform .9s linear; }
  .card:hover{ transform: translateY(-8px) rotateX(1deg); box-shadow: 0 30px 90px rgba(0,0,0,0.7); }
  .card.revealed::before{ transform: translateX(0%); }

  .card h3 { margin:0; font-size:1.15rem; color:var(--cyan); text-shadow:0 0 8px rgba(0,230,255,0.05) }
  .card p { margin:8px 0 14px; color:var(--muted); font-size:0.95rem }

  .card .meta { display:flex; gap:12px; align-items:center; justify-content:space-between; }
  .card .meta-left { display:flex; gap:12px; align-items:center; }
  .tag { padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--muted); font-weight:700; border:1px solid rgba(255,255,255,0.02) }

  /* gauge */
  .gauge { width:84px; height:84px; transform:translateZ(40px); }
  .gauge circle { transition: stroke-dashoffset 900ms cubic-bezier(.2,.9,.25,1); }

  /* modal (kept in markup but not used) */
  .modal-back { position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:60; display:flex; align-items:center; justify-content:center; }
  .modal { width:min(100%,980px); max-width:980px; background: linear-gradient(180deg, rgba(10,10,12,0.98), rgba(6,6,8,0.95)); border-radius:14px; padding:20px; border:1px solid rgba(255,255,255,0.04); box-shadow:0 30px 120px rgba(0,0,0,0.8); color:var(--muted); }
  .modal h2 { color:var(--magenta); margin:0 0 8px; }
  .modal .media { width:100%; height:340px; background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:8px; display:flex; align-items:center; justify-content:center; overflow:hidden; border:1px solid rgba(255,255,255,0.03); }
  .modal p { color:var(--muted) }

  /* terminal */
  .terminal { position:fixed; left:18px; bottom:18px; z-index:40; background:var(--bg-ui); padding:10px; border-radius:8px; font-family:'Share Tech Mono'; color:var(--accent); border:1px solid rgba(255,255,255,0.06); width:320px; box-sizing:border-box; }
  .terminal .out{ font-size:12px; max-height:140px; overflow:auto; color:#9bdcd8; margin-bottom:6px; }
  .terminal input{ width:100%; background:transparent; border:none; color:var(--accent); outline:none; padding:6px 8px; font-size:13px }

  /* responsive */
  @media (max-width:720px){
    .page{ padding:18px 12px 100px }
    .gauge{ width:64px;height:64px }
    .modal .media{ height:220px }
    .terminal{ width:86vw }
    .back-btn { right: 14px; bottom: 14px; }
    .back-btn .btn { font-size: 14px; padding: 10px 14px; }
  }

  @media (prefers-reduced-motion: reduce){
    .card, .card::before, .modal, canvas#bg-shader, canvas#particles { transition:none !important; animation:none !important; }
    .title{ animation:none; width:auto; border-right:0 }
  }

  /* SPA overlay (for preventing white flash) */
  #spa-overlay {
    position: fixed;
    inset: 0;
    z-index: 99999;
    pointer-events: none;
    background: linear-gradient(180deg,#03060a,#001428 60%);
    opacity: 0;
    transition: opacity .28s cubic-bezier(.2,.9,.25,1);
    will-change: opacity;
  }
  #spa-overlay.show { pointer-events: auto; opacity: 1; }
</style>
</head>
<body>

<!-- shader + particles -->
<canvas id="bg-shader" aria-hidden="true"></canvas>
<canvas id="particles" aria-hidden="true"></canvas>
<div class="screen-overlay" aria-hidden="true"></div>

<!-- SPA overlay -->
<div id="spa-overlay" aria-hidden="true"></div>

<!-- back button (bottom right) -->
<div class="back-btn">
  <a class="btn ghost" href="stud.html" id="backHome" data-spa>Back</a>
</div>

<!-- top UI -->
<div class="top-controls" role="toolbar" aria-label="Controls">
  <button class="hud-btn" id="resetBtn">RESET</button>
  <div class="perf-indicator" id="perf">ready</div>
</div>

<!-- content -->
<div class="page" role="main">
  <header>
    <div class="title">My Cyberpunk Projects</div>
  </header>

  <div class="toolbar" aria-hidden="false">
    <div class="search-wrap" style="margin-left:6px;">
      <!-- search removed as requested -->
      <button class="chip" data-tag="all">All</button>
      <button class="chip" data-tag="web">Web</button>
      <button class="chip" data-tag="iot">IoT</button>
      <button class="chip" data-tag="ml">ML</button>
    </div>
  </div>

  <section class="grid" id="projectsGrid" aria-label="Projects list">
    <!-- project cards injected by JS for convenience -->
  </section>
</div>

<!-- modal placeholder (kept but not used) -->
<div id="modalWrap" aria-hidden="true" style="display:none;"></div>

<!-- terminal -->
<div class="terminal" role="dialog" aria-label="Terminal">
  <div class="out" id="termOut">&gt; welcome. type <strong>help</strong></div>
  <form id="termForm"><input id="termInput" autocomplete="off" placeholder="enter command (help, projects, skills, contact)" /></form>
</div>

<script>
/* =========================
   Shared colors / helpers
   ========================= */
const COLORS = { cyan:'#00e6ff', magenta:'#b34bff', accent:'#88ffe6' };
function el(tag, attrs={}, children=[]){ const d = document.createElement(tag); for(const k in attrs) { if(k.startsWith('on') && typeof attrs[k] === 'function') d.addEventListener(k.slice(2), attrs[k]); else if(k === 'html') d.innerHTML = attrs[k]; else d.setAttribute(k, attrs[k]); } (Array.isArray(children)?children:[children]).forEach(c=>{ if(!c) return; if(typeof c === 'string') d.appendChild(document.createTextNode(c)); else d.appendChild(c); }); return d; }

/* =========================
   Projects data (demo)
   Replace with your real projects
   ========================= */
const PROJECTS = [
  { id:'p1', title:'Music Player', tags:['web'], desc:'Custom lofi music player with reactive visuals, playlist management and offline caching.', progress:90, screenshot:'' },
  { id:'p2', title:'Smart Vending Machine', tags:['iot'], desc:'IoT vending prototype with REST API, telemetry and admin dashboard.', progress:72, screenshot:'' },
  { id:'p3', title:'Business Website', tags:['web'], desc:'Responsive interior decor site with CMS integration and animations.', progress:82, screenshot:'' },
  { id:'p4', title:'ML Classifier', tags:['ml'], desc:'Prototype model for image classification and insights dashboard.', progress:60, screenshot:'' },
  { id:'p5', title:'Realtime Chat', tags:['web'], desc:'Low-latency chat with WebRTC and presence features.', progress:76, screenshot:'' },
];

/* =========================
   Shader background (WebGL2 preferred)
   Exposes window.__shaderSetHover & __shaderSetTimeScale for cross-page sync
   ========================= */
(function shaderInit(){
  const canvas = document.getElementById('bg-shader');
  let gl = canvas.getContext('webgl2');
  if(!gl){ gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if(!gl){ document.getElementById('perf').textContent = 'no WebGL'; return; } }

  function fit(){ const dpr = Math.max(1, window.devicePixelRatio||1); canvas.width = Math.floor(innerWidth * dpr); canvas.height = Math.floor(innerHeight * dpr); canvas.style.width = innerWidth+'px'; canvas.style.height = innerHeight+'px'; gl.viewport(0,0,canvas.width,canvas.height); }
  fit(); addEventListener('resize', fit);

  function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); return null; } return s; }

  const vs = `#version 300 es
    precision mediump float;
    in vec2 a_pos; out vec2 v_uv;
    void main(){ v_uv = a_pos*0.5 + 0.5; gl_Position = vec4(a_pos,0.0,1.0); }`;

  const fs = `#version 300 es
    precision highp float;
    in vec2 v_uv; out vec4 outColor;
    uniform vec2 u_resolution; uniform float u_time; uniform vec2 u_mouse; uniform float u_hover; uniform float u_audio;
    // hash / noise
    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }
    float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }
    float fbm(vec2 p){ float v=0.; float a=0.5; for(int i=0;i<5;i++){ v += a*noise(p); p *= 2.; a *= 0.5; } return v; }
    void main(){
      vec2 uv = v_uv; vec2 p = uv*2.0 - 1.0; p.x *= u_resolution.x/u_resolution.y;
      float t = u_time * 0.55;
      vec2 m = (u_mouse / u_resolution) * 2.0 - 1.0; m.x *= u_resolution.x/u_resolution.y;
      float dist = length(p - m);
      vec2 q = p + vec2(sin(t*0.35 + p.y*2.2)*0.012, cos(t*0.27 + p.x*2.2)*0.012);
      q += (p - m) * u_hover * exp(-dist*8.0) * 0.45;
      float n = fbm(q * (1.6 + u_audio*1.0) + t*0.06);
      vec3 base = mix(vec3(0.01,0.01,0.03), vec3(0.02,0.04,0.08), uv.y);
      vec3 neon = mix(vec3(0.02,0.6,0.5), vec3(0.65,0.18,1.0), n*0.6);
      vec3 col = base + neon * (n*0.8 + 0.06) * (0.9 + u_audio*0.65);

      float gx = abs(fract(uv.x * (12.0 + u_audio*8.0)) - 0.5);
      float gy = abs(fract(uv.y * (12.0 + u_audio*8.0)) - 0.5);
      float grid = (1.0 - smoothstep(0.495,0.5,gx))*0.18 + (1.0 - smoothstep(0.495,0.5,gy))*0.08;
      col += vec3(0.0,0.22,0.32) * grid * 0.06;

      // pointer bloom
      col += 0.35 * exp(-dist*8.0) * vec3(0.6,0.12,1.0) * u_hover;

      col = pow(clamp(col,0.,1.), vec3(0.95));
      outColor = vec4(col,1.0);
    }`;

  const vsS = compile(gl.VERTEX_SHADER, vs);
  const fsS = compile(gl.FRAGMENT_SHADER, fs);
  const prog = gl.createProgram(); gl.attachShader(prog, vsS); gl.attachShader(prog, fsS); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); document.getElementById('perf').textContent='shader fail'; return; }
  gl.useProgram(prog);

  const pos = new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.STATIC_DRAW);
  const aPos = gl.getAttribLocation(prog,'a_pos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  const uRes = gl.getUniformLocation(prog,'u_resolution');
  const uTime = gl.getUniformLocation(prog,'u_time');
  const uMouse = gl.getUniformLocation(prog,'u_mouse');
  const uHover = gl.getUniformLocation(prog,'u_hover');
  const uAudio = gl.getUniformLocation(prog,'u_audio');

  let start = performance.now();
  const state = { mouse:[innerWidth/2, innerHeight/2], hover:0, timeScale:1.0, targetTimeScale:1.0, audio:0 };

  window.addEventListener('mousemove', e => { state.mouse = [e.clientX, innerHeight - e.clientY]; });

  // Exposed API for other pages / interactions
  window.__shaderSetHover = (x,y, len=700) => { state.mouse = [x, innerHeight - y]; state.hover = 1.0; setTimeout(()=> state.hover = 0.0, len); };
  window.__shaderSetTimeScale = (v) => { state.targetTimeScale = Math.max(0.0001, Math.min(1, v)); };
  window.__shaderSetAudio = (v) => { state.audio = Math.max(0, Math.min(1, v)); };

  function render(now){
    const t = (now - start)/1000;
    state.timeScale += (state.targetTimeScale - state.timeScale) * 0.08;
    gl.useProgram(prog);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uTime, t * state.timeScale);
    gl.uniform2f(uMouse, state.mouse[0] || canvas.width/2, state.mouse[1] || canvas.height/2);
    gl.uniform1f(uHover, state.hover || 0.0);
    gl.uniform1f(uAudio, state.audio || 0.0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
})();

/* =========================
   Particles engine (neon orbs, audio-reactive)
   Exposes window.__particlesSetSpeed for other pages
   ========================= */
const particles = (function(){
  const canvas = document.getElementById('particles'); const ctx = canvas.getContext('2d', { alpha:true });
  let W=innerWidth, H=innerHeight; function fit(){ W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; canvas.style.width=W+'px'; canvas.style.height=H+'px'; }
  fit(); addEventListener('resize', fit);

  let pool = []; function build(n=120){ pool=[]; for(let i=0;i<n;i++){ pool.push({ x:Math.random()*W, y:Math.random()*H, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6, r:Math.random()*2.4+0.6, hue: 160 + Math.random()*160 }); } }
  build(120);

  let speedTarget=1, speed=1; window.__particlesSetSpeed = v => { speedTarget = Math.max(0.02, Math.min(1.0, v)); };

  function draw(){
    speed += (speedTarget - speed) * 0.12;
    ctx.clearRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';
    const audio = (window.__audioLevel || 0);
    for(const p of pool){
      p.x += p.vx * (1 + audio * 1.6) * speed;
      p.y += p.vy * (1 + audio * 1.6) * speed;
      if(p.x < -60) p.x = W + 60; if(p.x > W + 60) p.x = -60;
      if(p.y < -60) p.y = H + 60; if(p.y > H + 60) p.y = -60;
      const r = Math.max(0.6, p.r * (0.9 + audio*1.6));
      const grd = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r*10);
      grd.addColorStop(0, `hsla(${p.hue},92%,66%,${0.95 - (0.25 * audio)})`);
      grd.addColorStop(0.25, `hsla(${p.hue},82%,46%,${0.14 + audio*0.18})`);
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
    }
    ctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  return { rebuild: (n)=> build(n) };
})();

/* =========================
   UI: populate project cards, filters
   - clicking card no longer opens modal/demo/code
   - provides window.__initProjects() to re-initialize after SPA swaps
   ========================= */
(function UI(){
  const gridSel = '#projectsGrid';
  const chipsSel = '.chip';

  // Render the list into the DOM (create focusable divs instead of anchors; no click-to-open)
  function renderList(list){
    const grid = document.querySelector(gridSel);
    if(!grid) return;
    grid.innerHTML = '';
    list.forEach((p, idx)=>{
      // use div.card instead of <a> so clicking doesn't navigate / open modal
      const card = el('div', { class:'card', tabindex:0, 'data-id':p.id });
      const h = el('h3', {}, p.title);
      const desc = el('p', {}, p.desc);
      // gauge SVG
      const gauge = document.createElementNS('http://www.w3.org/2000/svg','svg');
      gauge.setAttribute('class','gauge'); gauge.setAttribute('viewBox','0 0 100 100'); gauge.setAttribute('aria-hidden','true');
      gauge.innerHTML = `<defs><linearGradient id="grad-${p.id}" x1="0%" x2="100%"><stop offset="0%" stop-color="${COLORS.cyan}"/><stop offset="100%" stop-color="${COLORS.magenta}"/></linearGradient></defs>
        <circle cx="50" cy="50" r="40" stroke="rgba(255,255,255,0.06)" stroke-width="10" fill="none"></circle>
        <circle class="gauge-fill" cx="50" cy="50" r="40" stroke="url(#grad-${p.id})" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="${2*Math.PI*40}" stroke-dashoffset="${2*Math.PI*40}"></circle>`;

      const metaLeft = el('div', { class:'meta-left' }, [
        el('div', { class:'tag' }, p.tags.join(', ').toUpperCase())
      ]);
      const meta = el('div', { class:'meta' }, [ metaLeft, gauge ] );
      card.appendChild(h); card.appendChild(desc); card.appendChild(meta);

      // interactions: hover ripple to shader (keeps visuals)
      card.addEventListener('mouseenter', (e) => {
        const r = card.getBoundingClientRect(); const cx = r.left + r.width/2; const cy = r.top + r.height/2;
        window.__shaderSetHover?.(cx, cy, 500);
        card.classList.add('hover');
        card.style.transform = 'translateY(-10px) rotateX(1deg)';
        if(Math.random()>0.82) { card.closest('.page')?.classList.add('streak'); setTimeout(()=> card.closest('.page')?.classList.remove('streak'),420); }
      });
      card.addEventListener('mouseleave', () => { card.classList.remove('hover'); card.style.transform=''; });

      // NOTE: clicked behavior removed by design (per your request)
      // card.addEventListener('click', (ev) => { ev.preventDefault(); /* removed openModal */ });

      grid.appendChild(card);

      // stagger reveal
      setTimeout(()=> card.classList.add('revealed'), 120 + idx * 90);
    });

    // animate gauge fills
    const fills = document.querySelectorAll('.gauge-fill');
    fills.forEach((g, i) => {
      const p = list[i];
      const circ = 2*Math.PI*40;
      const target = circ * (1 - (p.progress||70)/100);
      g.style.transition = 'stroke-dashoffset 900ms cubic-bezier(.2,.9,.25,1)';
      requestAnimationFrame(()=> g.style.strokeDashoffset = target);
    });
  }

  // Public init function to (re)wire chips and render list.
  // Safe to call repeatedly after SPA panel swaps.
  function initProjects(){
    const grid = document.querySelector(gridSel);
    if(!grid) return; // not on this page (early return)

    // attach chips behavior to the fresh DOM elements
    const chips = Array.from(document.querySelectorAll(chipsSel));
    let activeTag = 'all';

    function applyFilters(){
      const q = '';
      const filtered = PROJECTS.filter(p=>{
        const tagOk = activeTag === 'all' ? true : p.tags.includes(activeTag);
        const textOk = p.title.toLowerCase().includes(q) || p.desc.toLowerCase().includes(q) || p.tags.join(' ').includes(q);
        return tagOk && textOk;
      });
      renderList(filtered);
    }

    // clear previous active states and attach handlers (safe when called multiple times)
    chips.forEach(c => c.classList.remove('active'));
    const allChip = document.querySelector('.chip[data-tag="all"]');
    if(allChip) allChip.classList.add('active');

    chips.forEach(ch => {
      // remove any previously added listeners by cloning node (safer across re-inits)
      const newCh = ch.cloneNode(true);
      ch.parentNode.replaceChild(newCh, ch);
      newCh.addEventListener('click', () => {
        // remove active from all, add to this
        Array.from(document.querySelectorAll(chipsSel)).forEach(x => x.classList.remove('active'));
        newCh.classList.add('active');
        activeTag = newCh.dataset.tag;
        applyFilters();
      });
    });

    // initial render
    applyFilters();
  }

  // Expose for SPA reinit
  window.__initProjects = initProjects;

  // run immediately on first load
  try{ initProjects(); }catch(e){ console.warn('initProjects failed', e); }

})();

/* =========================
   Terminal mini
   ========================= */
(function Terminal(){
  const form = document.getElementById('termForm'), input = document.getElementById('termInput'), out = document.getElementById('termOut');
  function append(line){ out.innerHTML += '<div>'+line+'</div>'; out.scrollTop = out.scrollHeight; }
  form.addEventListener('submit', e=>{
    e.preventDefault();
    const v = (input.value||'').trim().toLowerCase();
    if(!v) return;
    append('&gt; '+v);
    if(v === 'help') append('commands: projects, skills, contact, status');
    else if(v === 'projects'){ append('opening projects...'); if(window.spaNavigate) window.spaNavigate('projects.html'); else location.href='projects.html'; }
    else if(v === 'skills'){ append('opening skills...'); if(window.spaNavigate) window.spaNavigate('skills.html'); else location.href='skills.html'; }
    else if(v === 'contact'){ append('opening contact...'); if(window.spaNavigate) window.spaNavigate('contact.html'); else location.href='contact.html'; }
    else if(v === 'status'){ append('visual status: shader+particles active'); }
    else append('unknown command — type help');
    input.value = '';
  });
})();

/* =========================
   Audio analyser hook (optional)
   Connect your analyser and update window.__audioLevel to drive visuals
   Example sets window.__audioLevel = 0..1
   ========================= */
window.__audioLevel = 0.0; // external code can write here (skills page uses similar pattern)

/* =========================
   quick bindings
   ========================= */
document.getElementById('resetBtn').addEventListener('click', ()=> location.reload());

/* =========================
   Auto-tune & boot messages
   ========================= */
(function Boot(){
  // tune particle counts based on deviceMemory
  const mem = navigator.deviceMemory || 4;
  if(mem <= 1){ particles.rebuild(28); document.getElementById('perf').textContent='low-power'; }
  else if(mem <= 2){ particles.rebuild(64); document.getElementById('perf').textContent='balanced'; }
  else { particles.rebuild(140); document.getElementById('perf').textContent='max visuals'; }
})();

/* =========================
   SPA navigation + overlay
   - intercepts same-origin internal links
   - falls back to normal navigation on failure or reduced motion
   - swaps `.page` region (so canvases + top UI stay persistent)
   - executes inline & external scripts from fetched document to re-initialize behaviour
   ========================= */
(function(){
  const overlay = document.getElementById('spa-overlay') || (function(){ const d=document.createElement('div'); d.id='spa-overlay'; document.body.appendChild(d); return d; })();
  function prefersReducedMotion(){ return window.matchMedia('(prefers-reduced-motion: reduce)').matches; }
  function showOverlay(){ overlay.classList.add('show'); }
  function hideOverlay(){ overlay.classList.remove('show'); }

  const PANEL_SELECTOR = '.page';

  function findPanel(doc){ return doc.querySelector(PANEL_SELECTOR); }

  // run scripts from fetched document (preserve order)
  async function runDocScripts(doc, baseUrl){
    const scripts = Array.from(doc.querySelectorAll('script'));
    for(const s of scripts){
      try{
        const t = (s.type||'').trim();
        if(t && t !== 'text/javascript' && t !== 'application/javascript' && t !== ''){
          if(t === 'module'){
            const sc = document.createElement('script');
            sc.type = 'module';
            if(s.src){
              sc.src = (new URL(s.src, baseUrl)).href;
              document.head.appendChild(sc);
              await new Promise(r=> sc.onload = sc.onerror = r);
            } else {
              sc.textContent = s.textContent;
              document.head.appendChild(sc);
            }
          }
          continue;
        }
        if(s.src){
          const sc = document.createElement('script');
          sc.async = false;
          sc.src = (new URL(s.src, baseUrl)).href;
          document.head.appendChild(sc);
          await new Promise(r=> sc.onload = sc.onerror = r);
        } else {
          try {
            (new Function(s.textContent))();
          } catch(e){
            console.error('inline script error', e);
          }
        }
      }catch(err){
        console.error('running script failed', err);
      }
    }
  }

  async function swapPanel(newPanelNode, url, pushState=true, fetchedDoc=null){
    if(!newPanelNode) return false;
    const oldPanel = document.querySelector(PANEL_SELECTOR);
    if(!oldPanel) return false;

    newPanelNode.classList.add(...(newPanelNode.classList.contains('page')? ['page','spa-fade-in'] : ['panel','spa-fade-in']));

    try{
      oldPanel.parentNode.insertBefore(newPanelNode, oldPanel.nextSibling);
      requestAnimationFrame(()=>{
        oldPanel.classList.add('spa-fade-out');
        setTimeout(()=>{ try{ oldPanel.remove(); }catch(e){}; newPanelNode.classList.remove('spa-fade-in'); }, 300);
      });
    }catch(e){
      oldPanel.replaceWith(newPanelNode);
    }

    try{ if(fetchedDoc && fetchedDoc.title) document.title = fetchedDoc.title; }catch(e){}

    if(pushState && url){
      try{ history.pushState({spa:true,url:url}, '', url); }catch(e){}
    }

    reinitAfterSwap();

    try{
      if(fetchedDoc){
        await runDocScripts(fetchedDoc, url);
        reinitAfterSwap();
      }
    }catch(e){
      console.warn('running fetched page scripts failed', e);
    }

    return true;
  }

  async function spaNavigate(href){
    if(prefersReducedMotion()){ location.href = href; return; }
    showOverlay();
    await new Promise(r => requestAnimationFrame(r));
    try{
      const resp = await fetch(href, { credentials: 'same-origin' });
      if(!resp.ok) throw new Error('fetch failed ' + resp.status);
      const text = await resp.text();
      const doc = new DOMParser().parseFromString(text, 'text/html');
      const newPanel = findPanel(doc);
      if(!newPanel){ location.href = href; return; }
      const cloned = newPanel.cloneNode(true);
      if(doc.title) document.title = doc.title;
      await swapPanel(cloned, href, true, doc);
      setTimeout(()=> hideOverlay(), 120);
    }catch(err){
      console.warn('SPA navigation failed', err);
      location.href = href;
    }
  }

  document.addEventListener('click', function(e){
    const a = e.target.closest && e.target.closest('a');
    if(!a || !a.href) return;
    if(a.hasAttribute('data-no-spa')) return;
    if(a.target && a.target !== '') return;
    if(a.hasAttribute('download')) return;
    const hrefAttr = a.getAttribute('href') || '';
    if(/^(mailto:|tel:|https?:\/\/)/i.test(hrefAttr) && (hrefAttr.indexOf(location.origin) !== 0)) return;
    const url = new URL(a.href, location.href);
    if(url.origin !== location.origin) return;
    if(url.pathname === location.pathname && url.hash) return;
    e.preventDefault();
    spaNavigate(url.href);
  });

  window.spaNavigate = spaNavigate;
  window.safeNavigate = function(href){ if(window.spaNavigate) window.spaNavigate(href); else location.href = href; };

  window.addEventListener('popstate', async function(ev){
    const href = location.href;
    if(prefersReducedMotion()){ location.href = href; return; }
    showOverlay();
    try{
      const resp = await fetch(href, { credentials: 'same-origin' });
      if(!resp.ok) throw new Error('fetch failed');
      const doc = new DOMParser().parseFromString(await resp.text(), 'text/html');
      const newPanel = findPanel(doc);
      if(!newPanel){ location.href = href; return; }
      const cloned = newPanel.cloneNode(true);
      if(doc.title) document.title = doc.title;
      await swapPanel(cloned, href, false, doc);
      setTimeout(()=> hideOverlay(), 120);
    }catch(e){
      location.href = href;
    }
  });

  function reinitAfterSwap(){
    // rebuild particles when panel swaps
    try{ if(window.particles && typeof window.particles.rebuild === 'function') window.particles.rebuild(); }catch(e){}

    // call the projects initializer if present (fixes "projects missing after SPA nav")
    try{ if(window.__initProjects && typeof window.__initProjects === 'function') window.__initProjects(); }catch(e){ console.warn('reinit projects failed', e); }

    try{
      const p = document.querySelector(PANEL_SELECTOR);
      if(p){
        const heading = p.querySelector('h2, h1, .title');
        if(heading){ heading.setAttribute('tabindex','-1'); heading.focus(); heading.removeAttribute('tabindex'); }
      }
    }catch(e){}
  }
})();

/* =========================
   End SPA block
   ========================= */
</script>
</body>
</html>
